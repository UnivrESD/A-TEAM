grammar proposition;

file : expression EOF;

//This grammar tries to narrow the possible types of an epression
//by exploiting informations from the operators, for example in the expression 
// "NEG subExp", the NEG operator forces subExp to be of type "Logic".
//The complete type of a subexpression will inferred at runtime in most cases.

//can be Bool, Numeric or Logic
 expression
    : LPAREN expression RPAREN
    | LGPAREN logic RGPAREN LCPAREN CONSTANT RCPAREN 
    | NextOp LCPAREN CONSTANT RCPAREN expression
    | PastOp LPAREN expression ',' CONSTANT RPAREN
    | NOT expression
    | numeric_logic relop numeric_logic
    | expression EQ expression
    | expression NEQ expression
    | expression boolop=AND expression
    | expression boolop=OR expression
    | numeric_logic
    | atom
    ;


//can be Numeric or Logic
numeric_logic
    : LPAREN numeric_logic RPAREN
    | NextOp LCPAREN CONSTANT RCPAREN numeric_logic
    | PastOp LPAREN numeric_logic ',' CONSTANT RPAREN
    | atom
    | logic
    | numeric_logic artop=(TIMES|DIV) numeric_logic
    | numeric_logic artop=(PLUS|MINUS) numeric_logic
    ;

//can only be Logic
logic
    : LPAREN logic RPAREN
    | LGPAREN logic RGPAREN LCPAREN CONSTANT RCPAREN 
    | LGPAREN logic RGPAREN LCPAREN upper_bound ':' lower_bound RCPAREN 
    | atom
    | NEG logic 
    | logic logop=BAND logic
    | logic logop=BOR logic
    ;


atom
    : constant
    | variable
    ;


constant
    :  CONSTANT
    ;

variable
    : VARIABLE
    ;
/*  : NextOp LCPAREN CONSTANT RCPAREN VARIABLE*/

NextOp
    : 'X'
    ;
PastOp
    : '$past'
    ;

LGPAREN
    : '{'
    ;

RGPAREN
    : '}'
    ;
LCPAREN
    : '['
    ;

RCPAREN
    : ']'
    ;

LPAREN
    : '('
    ;

RPAREN
    : ')'
    ;

upper_bound:
    CONSTANT
    ;

lower_bound:
    CONSTANT
    ;
//==== Token VARIABLE ==========================================================
VARIABLE
   : VALID_ID_START VALID_ID_CHAR*
   ;

fragment VALID_ID_START
    : ('a' .. 'z')
    | ('A' .. 'W')
    | ('Y' .. 'Z')
    | ('.')
    | '_'
    ;

fragment VALID_ID_CHAR
    : VALID_ID_START
    | ('0' .. '9')
    | ('.')
    | ('[')
    | (']')
    | (':')
    ;
//------------------------------------------------------------------------------


//==== Token constant ==========================================================
CONSTANT
   : NUMERIC
   | BINARY
   ;

fragment NUMERIC
   : ('0' .. '9') + ('.' ('0' .. '9') +)?
   ;
fragment BINARY
   : ('\'')('b')('0' .. '1')+
   ;
//------------------------------------------------------------------------------


//==== Arithmetic Operators ====================================================
PLUS
    : '+'
    ;

MINUS
    : '-'
    ;

TIMES
    : '*'
    ;

DIV
    : '/'
    ;
//------------------------------------------------------------------------------

//==== Relational Operators ====================================================
relop
    : GT
    | GE
    | LT
    | LE
    ;

GT
    : '>'
    ;

GE
    : '>='
    ;

LT
    : '<'
    ;

LE
    : '<='
    ;

EQ
    : '=='
    ;

NEQ
    : '!='
    ;
//------------------------------------------------------------------------------


//==== Logic Operators =========================================================

BAND
    : '&'
    ;

BOR
    : '|'
    ;

BXOR
    : '^'
    ;

NEG
    : '~'
    ;

//------------------------------------------------------------------------------


//==== Boolean Operators ========================================================

AND
    : '&&'
    ;

OR
    : '||'
    ;

NOT
    : '!'
    ;
//------------------------------------------------------------------------------

// Ignore: \r, \n, \t
WS : [ \t\r\n] -> skip;
